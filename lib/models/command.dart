/* *
 * Wirepas BLE communication example
 *
 * Made in the swiss alps, 2023 <marcel.graber@steinel.ch>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import 'dart:convert';

import 'package:flutter_reactive_ble/flutter_reactive_ble.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:flutter/foundation.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'command.freezed.dart';

@freezed
class CommandPayload with _$CommandPayload {
  static const int deviceBroadcast = 0xff;

  const factory CommandPayload.resendMessageRequest({
    required int messageId,
  }) = ResendMessageRequest;

  const factory CommandPayload.scanRequest({
    required int appVersion,
    required int hardwareOS,
  }) = ScanRequest;

  const factory CommandPayload.scanResponse({
    required int requestId,
    required int token,
    required int firmwareVersionMajor,
    required int firmwareVersionMinor,
    required int isSink,
  }) = ScanResponse;

  const factory CommandPayload.otapBeginUploadRequest({
    required int scratchpadSequence,
    required int scratchpadLength,
    required int packageLength,
  }) = OtapUploadWriteRequest;

  const factory CommandPayload.otapBeginUploadResponse({
    required int requestId,
    required int startMessageId,
    required int responseCode,
  }) = OtapBeginUploadResponse;

  const factory CommandPayload.otapUploadRequest({
    required Uint8List data,
  }) = OtapUploadRequest;

  const factory CommandPayload.otapUploadResponse({
    required int requestId,
    required int responseCode,
    required int percentageComplete,
  }) = OtapUploadResponse;

  const factory CommandPayload.error(String message) = _CommandPayloadError;
}

CommandPayload extractPayload(int command, ByteData data) {
  if (command == Command.cmdScanResponse && data.lengthInBytes == 7) {
    return CommandPayload.scanResponse(
      requestId: data.getUint16(0, Endian.little),
      token: data.getUint16(2, Endian.little),
      firmwareVersionMajor: data.getUint8(4),
      firmwareVersionMinor: data.getUint8(5),
      isSink: data.getUint8(6),
    );
  } else if (command == Command.cmdOtapBeginUploadResponse &&
      data.lengthInBytes == 5) {
    return CommandPayload.otapBeginUploadResponse(
      requestId: data.getUint16(0, Endian.little),
      startMessageId: data.getUint16(2, Endian.little),
      responseCode: data.getUint8(4),
    );
  } else if (command == Command.cmdOtapUploadResponse &&
      data.lengthInBytes == 4) {
    return CommandPayload.otapUploadResponse(
      requestId: data.getUint16(0, Endian.little),
      responseCode: data.getUint8(2),
      percentageComplete: data.getUint8(3),
    );
  } else if (command == Command.cmdResendMessageRequest &&
      data.lengthInBytes == 2) {
    return CommandPayload.resendMessageRequest(
      messageId: data.getUint16(0, Endian.little),
    );
  } else {
    debugPrint("Unknown command: $command, length: ${data.lengthInBytes}");
    return const CommandPayload.error('Invalid payload');
  }
}

String _toHexString(int number) =>
    '0x${number.toRadixString(16).padLeft(2, '0')}';

String commandToLocalName(int token, Command command) {
  var buffer = Utf8Decoder(allowMalformed: true)
      .convert(commandToByteBuffer(token, command, 0));
  debugPrint("decoded:");
  debugPrint(buffer.toString().length.toString());
  return buffer.toString();
}

String commandToServiceUuid(int token, Command command) {
  Uint8List buffer = commandToByteBuffer(token, command, 16);
  debugPrint(Uuid(buffer).toString());
  return Uuid(buffer).toString();
}

Uint8List commandToByteBuffer(int token, Command command, int len) {
  final data = command.when(
    (messageId, command, payload, reqeustId) {
      final payloadBytes = payload.maybeMap(
        scanRequest: (scanRequest) {
          final data = ByteData(2);
          data.setUint8(0, scanRequest.appVersion);
          data.setUint8(1, scanRequest.hardwareOS);
          return data.buffer.asUint8List();
        },
        otapUploadRequest: (otapUploadRequest) {
          final data = ByteData(otapUploadRequest.data.length);
          data.buffer.asUint8List().setAll(0, otapUploadRequest.data);
          return data.buffer.asUint8List();
        },
        otapBeginUploadRequest: (otapBeginUploadRequest) {
          final data = ByteData(8);
          data.setUint16(0, token,
              Endian.little); // we only send 2 Bytes of Cmodul Address
          data.setUint8(2, otapBeginUploadRequest.scratchpadSequence);
          data.setUint32(
              3, otapBeginUploadRequest.scratchpadLength, Endian.little);
          data.setUint8(7, otapBeginUploadRequest.packageLength);
          return data.buffer.asUint8List();
        },
        orElse: () => Uint8List(0),
        error: (error) => Uint8List(0),
      );

      // 3 Bytes header + payload + CRC8
      //

      final data = ByteData((len == 0) ? (3 + payloadBytes.length) : len);
      // final data = ByteData(3 + payloadBytes.length + 1);
      //data.setAll(0);
      data.setUint16(0, messageId, Endian.little);
      data.setUint8(2, command);
      data.buffer.asUint8List().setAll(3, payloadBytes);
      debugPrint(
          "send: ${data.buffer.asUint8List().map(_toHexString).toList()}");

      return data.buffer.asUint8List();
    },
    error: (_) {
      return Uint8List(8);
    },
  );
  return data;
}

@freezed
class Command with _$Command {
  static const int cmdResendMessageRequest = 0x01;
  static const int cmdScanRequest = 0x02;
  static const int cmdScanResponse = 0x82;

  static const int cmdOtapBeginUploadRequest = 0x0A;
  static const int cmdOtapBeginUploadResponse = 0x8A;
  static const int cmdOtapUploadRequest = 0x0B;
  static const int cmdOtapUploadResponse = 0x8B;

  factory Command({
    required int messageId,
    required int command,
    required CommandPayload payload,
    @Default(0) int requestId,
  }) = _Command;

  const factory Command.error(String message) = _CommandError;

  factory Command.fromManufacturerData(Uint8List input) {
    // first we get the two byte company id from manufacturing data
    var messageId = input[3] << 8 | input[2];

    debugPrint("data rx: ${input.map(_toHexString).toList()}");

    var requestId = input[6] << 8 | input[5];

    // use ByteData to read little endian data
    ByteData raw = ByteData.view(Uint8List.fromList(input.sublist(4)).buffer);
    // remove Command from payload
    ByteData payloadData =
        ByteData.view(Uint8List.fromList(input.sublist(5)).buffer);
    var command = raw.getUint8(0);

    return Command(
      messageId: messageId,
      command: command,
      payload: extractPayload(command, payloadData),
      requestId: requestId,
    );
  }
}
